# 从一个数组中找出 N 个数，其和为 M 的所有可能

## 降维分析

如何从在数组中取N个数，并对其求和。

假设N=2；从数组 [1, 5, 8, 10, 12] 中找到两个数和为 9，返回 [1, 8] 这样的结果。

我们的解法，先拎出来一个，然后与剩余的数相加等于M=9；

**代码：**

```Javascript
function findSumIsBy2(arr, N=2, M=9) {
    const result = [];
    const len = arr.length;
    // 先拎出来一个
  	for (let i=0; i < len; i++) {
        // 再从剩余列表中在拎出来一个
        for (let j = i+1; j < len; j++) {
            if (arr[i] + arr[j] === M) {
                result.push([arr[i], arr[j]]);
            }
        }
    }
  	return result;
}
```

## N很大时

那么问题来了，当 N = 3 呢，N = 10 呢，会发现运算量越来越大，之前的方式已经不可行了。



## 思路

- 数组中选取不固定数值N（N <= length）,那么就是从`length`个数选取N个数的组合的和等于M，我们可以尝试标记的方式。

将选取状态记为1，未选取记为0；

- 假设数组 const arr = [1,2,3,4]；对应每个元素都有标记0或1；如果N=4，那么在数组中要选出四个元素，那么对应的标记这有一种1111；如果N=3时。对应的标记有四种[0111, 1011, 1101, 1110]；(也就是 C4取3->4 ) 种可能



## 开始抽象

标记中有几个1，就代表选中了几个数，然后再去遍历这些 1 所有可能存在的排列方式，然后判断：每种排列方式都代表着数组中被选中的位置的数的组合。所以这里就是将选中的这些数字，进行求和运算，然后判断求出的和是不是等于 M 。



## 数组和标记关联

**0101这样的数据看上去的第一反应就是二进制**

- 对于arr来说，有4个元素，对应选择的方式，就是（N=1）0000到（N=4）1111的所有可能；

- 而 1111 就是 15 的二进制，也就是说这所有的可能其实对应的就是 0 - 15 中所有数对应的二进制。

**这里我们可以根据数组的长度推到出0-15**

我们采用左移位的方式`1 >> 4` 结果 16；

这里我们可以建立一个迭代

```js
function findSumIsBy2(arr, N, M) {
  	const len = arr.length;
    const size = 1 >> len - 1;
    for (let i = 0; i < size; i++) {
        
    }
}
```



## 找出1个数为N的排列

1、 简单的方式

```js
const _n = num => num.toString(2).replace(/0/g, '').length;
```

2、&运算

- 首先我们肯定知道 1 & 1 = 1; 1 & 0 = 0 这些结论的。
- 我们从 15 & 14 => 14 可以推导出 1111 & 1110 => 1110 ，为什么可以这样推导呢，因为 15 的二进制就是 1111 ，14 同理。我们可以看到，通过上面的操作消掉了最后的 1。

```js
const _n = num => {
    let count = 0;
    while( num !== 0) {
        num &= (num - 1);
        count++;
    }
    return count;
}
```

**1个数为N的排列**

```js
function findSumIsBy2(arr, N=2, M=9) {
  	const len = arr.length;
    const size = 1 >> len - 1;
    for (let i = 0; i < size; i++) {
        if (_n(i) === n) {
            
        }
    }
}
```



## 计算和等于 **M**

现在我们已经可以把所有的选取可能转变为遍历一个数组，然后通过迭代数组中的每个数对应的二进制，有几个 1 来确定选取元素的个数。

这里其实就是建立一个映射：

- 1110 到 [1, 2, 3, 4] 的映射，就代表选取了 2, 3, 4，然后判断 2 + 3 + 4 与 M 。
- 这里可以这样看：1110 中的左边第一个 1 对应着数组 [1, 2, 3, 4] 中的 4 。

现在有一个问题，该如何建立这个映射关系呢？

- 我们知道前者 1110 其实就是对应的外层遍历中的 i = 14 的情况。
- 再看看数组[1, 2, 3, 4] ，我们可以将元素及其位置分别映射为 1000 0100 0010 0001。
- 实现方式也是通过位运算--左位移来实现：
- 1 << inx ，inx 为数组的下标。

## 利用掩码

```js
const _n = num => num.toString(2).replace(/0/g, '').length;
function findSumIsBy2(arr, N=2, M=9) {
  	const result = [];
  	const len = arr.length;
    const size = (1 << len) - 1;
    for (let i = 0; i < size; i++) {
        if (_n(i) === N) {
            let sum = 0, temp = [];
          	for(let j=0; j < len; j++) {
                if ( (i & (1 << j)) !== 0) {
                    sum+= arr[j];
                  	temp.push(arr[j]);
                }
            }
            if (sum === M) {
                result.push(temp);
            }
        }
    }
    return result;
}
```

